//@version=5
indicator("الفوليوم بروفايل ملتصق", overlay=true, max_boxes_count=500, max_bars_back=500)

// الإعدادات
bbars = input.int(150, "عدد الشموع", minval=20, maxval=500)
rows = input.int(70, "عدد الصفوف", minval=10, maxval=300)
vaPct = input.float(70.0, "نسبة منطقة القيمة %", minval=0, maxval=100)
scale = input.float(24.0, "حجم البارات (وحدات عرض)", minval=1, maxval=200)
colVA = input.color(color.new(color.yellow, 0), "لون داخل VA")
colOut = input.color(color.new(color.white, 0), "لون خارج VA")
colPOC = input.color(color.red, "لون خط POC")
pocWidth = input.int(2, "عرض خط POC", minval=1, maxval=5)

// نطاق الحساب - ثابت على الشارت
top = ta.highest(high, bbars)
bot = ta.lowest(low, bbars)
step = (top - bot) / rows
dist = (top - bot) / 500 // هامش رفيع لمنع تلاصق البارات

// مستويات الأسعار
levels = array.new_float(rows + 1, 0.0)
for i = 0 to rows
    array.set(levels, i, bot + step * i)

// دالة حساب طول تقاطع مقطعين [a,b] و [c,d]
getOverlap(a, b, c, d) =>
    hi = math.min(math.max(a, b), math.max(c, d))
    lo = math.max(math.min(a, b), math.min(c, d))
    math.max(hi - lo, 0)

// نحسب مرة واحدة على آخر شمعة ونرسم
if barstate.islast
    vols = array.new_float(rows, 0.0)
    
    // توزيع كامل فوليوم كل شمعة على المستويات بحسب طول التقاطع مع [low,high]
    for b = 0 to bbars - 1
        lo = low[b]
        hi = high[b]
        rng = math.max(hi - lo, syminfo.mintick)
        for i = 0 to rows - 1
            ov = getOverlap(array.get(levels, i), array.get(levels, i + 1), lo, hi)
            array.set(vols, i, array.get(vols, i) + (ov / rng) * volume[b])
    
    // POC
    pocIdx = array.indexof(vols, array.max(vols))
    pocLvl = (array.get(levels, pocIdx) + array.get(levels, pocIdx + 1)) / 2
    
    // منطقة القيمة VA (توسيع حول الـ POC حتى نغطي vaPct%)
    target = array.sum(vols) * vaPct / 100.0
    acc = array.get(vols, pocIdx)
    up = pocIdx
    dn = pocIdx
    
    while acc < target
        upV = up < rows - 1 ? array.get(vols, up + 1) : 0.0
        dnV = dn > 0 ? array.get(vols, dn - 1) : 0.0
        if upV >= dnV
            up += 1
            acc += upV
        else
            dn -= 1
            acc += dnV
    
    maxV = array.max(vols)
    
    // تحديد موضع ثابت للبروفايل (بداية ونهاية ثابتة)
    profileStart = bar_index - bbars + 1
    profileEnd = bar_index
    
    // رسم البارات ثابتة الموضع
    var box[] bars = array.new_box(rows, na)
    for i = 0 to rows - 1
        if not na(array.get(bars, i))
            box.delete(array.get(bars, i))
        w = maxV > 0 ? math.round(array.get(vols, i) / maxV * scale) : 0
        left = profileStart
        right = profileStart + int(w) // العرض النسبي يبدأ من بداية البروفايل
        topY = array.get(levels, i + 1) - dist
        botY = array.get(levels, i) + dist
        clr = (i >= dn and i <= up) ? colVA : colOut
        newB = box.new(left, topY, right, botY, border_width=0, bgcolor=clr)
        array.set(bars, i, newB)
    
    // خط POC ثابت من بداية إلى نهاية البروفايل
    var line pocLine = na
    if not na(pocLine)
        line.delete(pocLine)
    pocLine := line.new(profileStart, pocLvl, profileEnd, pocLvl, extend=extend.none, color=colPOC, width=pocWidth)